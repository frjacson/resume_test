<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // class Commitment {
      //   static PENDING = "pending";
      //   static FULFILLED = "fulfilled";
      //   static REJECTED = "rejected";
      //   constructor(func) {
      //     this.status = Commitment.PENDING;
      //     this.result = null;
      //     this.resolveCallbacks = [];
      //     this.rejectCallbacks = [];
      //     try {
      //       func(this.resolve.bind(this), this.reject.bind(this));
      //     } catch (error) {
      //       this.reject(error);
      //     }
      //   }
      //   resolve(result) {
      //     setTimeout(() => {
      //       if (this.status === Commitment.PENDING) {
      //         this.status = Commitment.FULFILLED;
      //         this.result = result;
      //         this.resolveCallbacks.forEach((callback) => {
      //           callback(result);
      //         });
      //       }
      //     });
      //   }
      //   reject(result) {
      //     setTimeout(() => {
      //       if (this.status === Commitment.PENDING) {
      //         this.status = Commitment.REJECTED;
      //         this.result = result;
      //         this.rejectCallbacks.forEach((callback) => {
      //           callback(result);
      //         });
      //       }
      //     });
      //   }
      //   then(onFulfilled, onRejected) {
      //     //传递的要是一个函数
      //     return new Commitment((resolve, reject) => {
      //       onFulfilled =
      //         typeof onFulfilled === "function" ? onFulfilled : () => {};
      //       onRejected =
      //         typeof onRejected === "function" ? onRejected : () => {};
      //       if (this.status === Commitment.PENDING) {
      //         this.resolveCallbacks.push(onFulfilled);
      //         this.rejectCallbacks.push(onRejected);
      //       }
      //       if (this.status === Commitment.FULFILLED) {
      //         setTimeout(() => {
      //           onFulfilled(this.result);
      //         });
      //       }
      //       if (this.status === Commitment.REJECTED) {
      //         setTimeout(() => {
      //           onRejected(this.result);
      //         });
      //       }
      //     });
      //   }
      // }

      class Commitment {
        static PENDING = "pending";
        static FULFILLED = "fulfilled";
        static REJECT = "reject";
        constructor(func) {
          this.status = Commitment.PENDING;
          this.result = null;
          this.resoveCallbacks = [];
          this.rejectCallbacks = [];
          try {
            func(this.resolve.bind(this), this.reject.bind(this));
          } catch (err) {
            this.reject(err);
          }
        }
        resolve(result) {
          setTimeout(() => {
            if (this.status === Commitment.PENDING) {
              this.status = Commitment.FULFILLED;
              this.result = result;
              this.resoveCallbacks.forEach((callback) => {
                callback(result);
              });
            }
          });
        }
        reject(result) {
          setTimeout(() => {
            if (this.status === Commitment.PENDING) {
              this.status = Commitment.REJECT;
              this.result = result;
              this.rejectCallbacks.forEach((callback) => {
                callback(result);
              });
            }
          });
        }
        then(onFulfilled, onRejected) {
          onFulfilled =
            typeof onFulfilled === "function" ? onFulfilled : () => {};
          onRejected = typeof onRejected === "function" ? onRejected : () => {};
          if (this.status === Commitment.PENDING) {
            this.resoveCallbacks.push(onFulfilled);
            this.rejectCallbacks.push(onRejected);
          }
          if (this.status === Commitment.FULFILLED) {
            setTimeout(() => {
              onFulfilled(this.result);
            });
          }
          if (this.status === Commitment.REJECT) {
            setTimeout(() => {
              onRejected(this.result);
            });
          }
        }
      }

      let commitment = new Commitment((resolve, reject) => {
        setTimeout(() => {
          resolve("hello");
          console.log("nihao");
        });
      });
      commitment.then(
        (result) => {
          console.log(result);
        },
        (result) => {
          console.log(result);
        }
      );
    </script>
  </body>
</html>
